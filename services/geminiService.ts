import { GoogleGenAI, Type } from "@google/genai";
import { Question, Topic, StudentSnapshot, SearchResult } from "../types";

/**
 * GeminiService: "Bộ não" trung tâm điều hành mọi tác vụ AI của ứng dụng.
 */
export class GeminiService {
  // =========================
  // Helpers
  // =========================

  private static ensureUpperLetter(x: any, fallback: string = "A"): string {
    const s = String(x ?? "").trim().toUpperCase();
    return ["A", "B", "C", "D", "TRUE", "FALSE", "T", "F", "ĐÚNG", "SAI"].includes(s) ? s : fallback;
  }

  /**
   * Convert teacher JSON schema to app Question schema.
   * Teacher schema example:
   * {
   *   "qid": "t01_q001",
   *   "type": "mcq",
   *   "level": "C1",
   *   "stem": "...",
   *   "choices": [{"id":"A","text":"..."}, ...],
   *   "answer_key": "B"
   * }
   *
   * App schema (as generated by Gemini in this repo):
   * {
   *   qid, type, skill_tag, difficulty, prompt, choices: {A,B,C,D}, answer_key, explain
   * }
   */
  private static normalizeFromStaticJSON(raw: any, index: number): Question {
    const qid = String(raw?.qid ?? `t01_q${String(index + 1).padStart(3, "0")}`);

    // Normalize type
    const rawType = String(raw?.type ?? "MCQ").toUpperCase();
    // Accept: "mcq" | "MCQ" | "tf" | "TF" | "fill" | "FILL"
    const type =
      rawType.includes("TF") ? "TF" :
      rawType.includes("FILL") ? "FILL" :
      "MCQ";

    // Skill tag
    const skill_tag = ["C1", "C2", "C3", "C4"].includes(String(raw?.level ?? raw?.skill_tag).toUpperCase())
      ? String(raw?.level ?? raw?.skill_tag).toUpperCase()
      : "C1";

    // Prompt text
    const prompt = String(raw?.stem ?? raw?.prompt ?? "").trim();

    // Choices: teacher uses array; app expects object {A,B,C,D}
    let choicesObj: any = undefined;
    const rawChoices = raw?.choices;

    if (type === "MCQ") {
      if (Array.isArray(rawChoices)) {
        const map: Record<string, string> = { A: "", B: "", C: "", D: "" };
        for (const c of rawChoices) {
          const k = String(c?.id ?? "").trim().toUpperCase();
          const v = String(c?.text ?? "").trim();
          if (["A", "B", "C", "D"].includes(k)) map[k] = v;
        }
        // if empty, provide placeholders
        choicesObj = {
          A: map.A || "...",
          B: map.B || "...",
          C: map.C || "...",
          D: map.D || "...",
        };
      } else if (rawChoices && typeof rawChoices === "object") {
        // already object-like
        choicesObj = {
          A: String(rawChoices.A ?? "..."),
          B: String(rawChoices.B ?? "..."),
          C: String(rawChoices.C ?? "..."),
          D: String(rawChoices.D ?? "..."),
        };
      } else {
        choicesObj = { A: "...", B: "...", C: "...", D: "..." };
      }
    }

    // Answer key normalization
    const answer_key = this.ensureUpperLetter(raw?.answer_key, type === "TF" ? "TRUE" : "A");

    // Difficulty (optional)
    const difficulty = Number.isFinite(Number(raw?.difficulty)) ? Number(raw.difficulty) : 1;

    // Explain (optional, but UI often expects something)
    const explain =
      String(raw?.explain ?? "").trim() ||
      `[CORE FACT]: ${skill_tag}. [DEEP DIVE]: Câu hỏi lấy từ bộ đề tĩnh (GitHub) của chuyên đề #1. [PRO TIP]: Ôn đúng từ khóa trong prompt.`;

    return {
      ...raw,
      qid,
      type,
      skill_tag,
      difficulty,
      prompt,
      choices: type === "MCQ" ? choicesObj : undefined,
      answer_key,
      explain,
    } as Question;
  }

  private static async loadStaticTopicQuestions(topicId: string): Promise<Question[]> {
    const url = `/data/topics/${topicId}.json`;

    // IMPORTANT: fetch from public folder on Vercel
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) {
      throw new Error(`Cannot load ${url}: ${res.status}`);
    }

    const data = await res.json();
    const rawQuestions = Array.isArray(data?.questions) ? data.questions : [];

    // Normalize into app Question schema
    const normalized = rawQuestions.map((q: any, i: number) => this.normalizeFromStaticJSON(q, i));

    // Basic validation: must have prompt
    const cleaned = normalized.filter(q => String((q as any).prompt ?? "").trim().length > 0);

    return cleaned;
  }

  // =========================
  // [1] TẠO QUIZ
  // =========================
  static async generateQuiz(
    topic: Topic,
    count: 10 | 25,
    isArena: boolean = false
  ): Promise<Question[]> {
    const topicId = String(topic?.id ?? "");

    // ✅ HARD OVERRIDE: Topic #1 always uses static JSON (no Gemini)
    if (topicId === "1") {
      const qs = await this.loadStaticTopicQuestions("1");

      // If file has 25 but caller wants 10, slice. If wants 25, keep 25.
      if (count === 10) return qs.slice(0, 10);
      return qs.slice(0, 25);
    }

    // Other topics: use Gemini
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    const ai = new GoogleGenAI({ apiKey });

    const systemInstruction = `BẠN LÀ "BỘ NÃO KHẢO THÍ ĐỊA AI" - CHUYÊN GIA SỐ 1 VỀ ĐỊA LÍ 8 (BỘ KNTT).
NHIỆM VỤ: Soạn bộ đề luyện năng lực cao cấp cho chuyên đề: "${topic.full_text}".
${isArena ? 'CHẾ ĐỘ: ARENA COMBAT (Yêu cầu các câu hỏi lắt léo, bẫy tư duy, đòi hỏi kỹ năng C3-C4 cao).' : ''}

YÊU CẦU KỸ THUẬT QUAN TRỌNG:
1. LOẠI CÂU HỎI: Phối hợp MCQ (A,B,C,D), TF (Nhận định Đúng/Sai), và FILL (Điền khuyết).
2. TF phải là nhận định phức hợp: [Hiện tượng] + [Nguyên nhân] + [Hệ quả/Đặc điểm chi tiết], có bẫy logic.
3. CHUẨN NĂNG LỰC: skill_tag thuộc C1-C4.
4. GIẢI THÍCH (BẮT BUỘC): explain theo cấu trúc [CORE FACT] / [DEEP DIVE] / [PRO TIP].
5. TRẢ VỀ JSON THUẦN TÚY. KHÔNG CÓ TEXT THỪA.`;

    try {
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: `Generate ${count} specialized questions for topic: ${topic.keyword_label}. Focus on complex TF (Identification) questions with logical traps.`,
        config: {
          systemInstruction,
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.OBJECT,
            properties: {
              questions: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    qid: { type: Type.STRING },
                    type: { type: Type.STRING },
                    skill_tag: { type: Type.STRING },
                    difficulty: { type: Type.NUMBER },
                    prompt: { type: Type.STRING },
                    choices: {
                      type: Type.OBJECT,
                      properties: {
                        A: { type: Type.STRING },
                        B: { type: Type.STRING },
                        C: { type: Type.STRING },
                        D: { type: Type.STRING },
                      },
                    },
                    answer_key: { type: Type.STRING },
                    explain: { type: Type.STRING },
                  },
                  required: ["qid", "type", "skill_tag", "difficulty", "prompt", "answer_key", "explain"],
                },
              },
            },
            required: ["questions"],
          },
        },
      });

      const parsed = JSON.parse(response.text || `{"questions":[]}`);
      const questions = Array.isArray(parsed?.questions) ? parsed.questions : [];

      // Normalize a bit for safety
      return questions.map((q: any) => ({
        ...q,
        qid: q.qid || `Q-${Math.random().toString(36).slice(2, 7)}`,
        type: String(q.type || "MCQ").toUpperCase(),
        skill_tag: ["C1", "C2", "C3", "C4"].includes(String(q.skill_tag).toUpperCase())
          ? String(q.skill_tag).toUpperCase()
          : "C1",
        difficulty: Number.isFinite(Number(q.difficulty)) ? Number(q.difficulty) : 1,
        prompt: String(q.prompt || "").trim(),
        choices: String(q.type || "").toUpperCase() === "MCQ"
          ? (q.choices || { A: "...", B: "...", C: "...", D: "..." })
          : undefined,
        answer_key: this.ensureUpperLetter(q.answer_key, "A"),
        explain:
          String(q.explain || "").trim() ||
          "[CORE FACT]: ... [DEEP DIVE]: ... [PRO TIP]: ...",
      })) as Question[];
    } catch (error) {
      console.error("GeminiService.generateQuiz Error:", error);
      throw error;
    }
  }

  // =========================
  // [2] PHÂN TÍCH CHIẾN LƯỢC
  // =========================
  static async analyzeClassStrategy(students: StudentSnapshot[]): Promise<string> {
    if (!students || students.length === 0) return "Không có dữ liệu học sinh để phân tích.";

    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) return "Thiếu GEMINI_API_KEY nên không thể phân tích AI.";

    const ai = new GoogleGenAI({ apiKey });

    const avgMastery = Math.round(students.reduce((a, s) => a + (s.avgMastery || 0), 0) / students.length);
    const criticalCount = students.filter((s) => s.status === "CRITICAL").length;

    const prompt = `Bạn là Hội đồng Chiến lược Giáo dục Địa AI.
Phân tích dữ liệu Matrix 33 chuyên đề của ${students.length} học sinh.
Mastery trung bình lớp: ${avgMastery}%.
Số HS nguy cấp (<40%): ${criticalCount}.
Hãy đưa ra 3 phương án can thiệp NANO-MATRIX chiến lược.`;

    try {
      const response = await ai.models.generateContent({
        model: "gemini-3-pro-preview",
        contents: prompt,
      });
      return response.text || "Phân tích thất bại.";
    } catch (error) {
      console.error("GeminiService.analyzeClassStrategy Error:", error);
      return "Lỗi AI: " + (error as Error).message;
    }
  }

  // =========================
  // [3] TRA CỨU INSIGHT
  // =========================
  static async fetchTopicInsights(topic: Topic): Promise<SearchResult> {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) return { summary: "Thiếu GEMINI_API_KEY nên không thể tra cứu.", sources: [] };

    const ai = new GoogleGenAI({ apiKey });

    const prompt = `Tóm tắt kiến thức cốt lõi và các từ khóa quan trọng cho chuyên đề: "${topic.keyword_label}".
Dựa trên chương trình Địa lí 8 Kết nối tri thức. Ngắn gọn, súc tích.`;

    try {
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: prompt,
        config: { tools: [{ googleSearch: {} }] },
      });

      const summary = response.text || "Không tìm thấy thông tin tóm tắt.";
      const chunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
      const sources = chunks
        .filter((c: any) => c.web)
        .map((c: any) => ({ title: c.web.title, uri: c.web.uri }));

      return { summary, sources: sources.slice(0, 3) };
    } catch (error) {
      console.error("GeminiService.fetchTopicInsights Error:", error);
      return { summary: "Lỗi kết nối tra cứu.", sources: [] };
    }
  }
}
